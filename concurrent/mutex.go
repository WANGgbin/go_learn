package concurrent

// sync.Mutex 与 runtime.Mutex
// sync.Mutex 是专属于协程的互斥锁，runtime.Mutex 是专属于线程的互斥锁。

// 问题
// 1、为什么要设计 sync.Mutex，而不是直接使用 runtime.Mutex？
// 如果协程因为竞争问题，总是导致所在的线程睡眠，会影响到整个 go 程序的并发度，因为 go 程序中能创建的线程数量是有上限的，
// 极端情况下，创建的协程数量 == 线程数量。另一方面，使用线程锁，涉及到 用户态 到 内核态的转化以及线程上下问的切换。所以
// 需要一种专门针对于协程的锁，保证协程睡眠的时候不会影响到所在的线程的运行状态。

// 2、sync.Mutex 实现原理
// sync.Mutex 本质上是通过 runtime.Mutex 实现的，sync.Mutex 基于 runtime.Sema 而 runtime.Sema 底层是通过 runtime.Mutex 实现的。
// sync.Mutex 专注于协程之间的互斥，而 runtime.Mutex 专注于 runtime.Sema 底层排队队列的互斥。队列的操作是个极短的临界区，同时 runtime.Mutex
// 是优化后的线程锁，通常首先尝试自旋，如果自旋还是获取不到锁，才会调用操作系统级的线程锁睡眠。所以，基本上线程不会睡眠，即使睡眠也能很快恢复运行。
// 最后的记过就是，协程睡眠被加入到对应的等待队列中，但是线程继续运行。
// 本质上，就是将本来的较大的业务临界区，现在限制到队列的极短临界区，同时通过优化的线程锁，保证线程基本不睡眠的情况下，完成协程的排队、调度。


