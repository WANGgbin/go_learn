# 一些重要结论

- go test 为每一个 pkg 生成一个 binary，测试完毕后，会删除该 binary.
- go 中的测试单元是按照 **父子关系**组织的。只有当所有的子测试执行完毕，父测试才算执行完毕。go test 会为 pkg 中的所有 Test 抽象一个父 Test，该 Test 负责运行所有的子 Test

# testing.common

不管是 testing.T 还是 testing.B 在一些实现方面很类似，这部分通过 testing.common 实现。

我们看看该结构体的主要字段：
```go
// common holds the elements common between T and B and
// captures common methods such as Errorf.
type common struct {
	mu          sync.RWMutex         // guards this group of fields
	output      []byte               // Output generated by test or benchmark.
	w           io.Writer            // For flushToParent.
	ran         bool                 // Test or benchmark (or one of its subtests) was executed.
	failed      bool                 // Test or benchmark has failed.
	skipped     bool                 // Test or benchmark has been skipped.
	done        bool                 // Test is finished and all subtests have completed.
	helperNames map[string]struct{}  // helperPCs converted to function names
	cleanups    []func()             // optional functions to be called at the end of the test
	cleanupName string               // Name of the cleanup function.
	finished    bool                 // Test function has completed. 注意 finished 与 done 的区别，finished 表示当前测试函数执行完毕，但是该测试对应的子测试不一定执行完毕。而 done 表示 当前测试以及所有的子测试都执行完毕。
	inFuzzFn    bool                 // Whether the fuzz target, if this is one, is running.

	bench          bool           // Whether the current test is a benchmark.
	hasSub         atomic.Bool    // whether there are sub-benchmarks.
	cleanupStarted atomic.Bool    // Registered cleanup callbacks have started to execute
	raceErrors     int            // Number of races detected during test.
	runner         string         // Function name of tRunner running the test.
	isParallel     bool           // Whether the test is parallel. 

	parent   *common // 父子关系
	level    int       // Nesting depth of test or benchmark.
	name     string    // Name of test or benchmark.
	start    time.Time // Time test or benchmark started
	duration time.Duration
	barrier  chan bool // To signal parallel subtests they may start. 
	signal   chan bool // To signal a test is done. 表明，当前 test 结束
	sub      []*T      // Queue of subtests to be run in parallel. 以 parallel 方式运行的子测试。如果是以非 parallel 方式运行的子测试，并不会加入到 sub 中。
}
```
# testing.T

testing.T 是实现单元测试的核心数据结构。

## t.Run()

t.Run() 方法负责以一个单独的协程来执行一个子测试，对于 parallel 子测试，只是拉起。

```go
// Run runs f as a subtest of t called name. It runs f in a separate goroutine
// and blocks until f returns or calls t.Parallel to become a parallel test.
// Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
func (t *T) Run(name string, f func(t *T)) bool {
    // 创建子 t
	t = &T{
		common: common{
			barrier: make(chan bool),
			signal:  make(chan bool, 1),
			name:    testName,
			parent:  &t.common, // 父子关系
			level:   t.level + 1,
		},
		context: t.context, // 直接继承父 t 的 ctx
	}

    // 通过协程来执行子测试
	go tRunner(t, f)
	if !<-t.signal { // 等待子测试结束。但是对于 parallel 子测试，在执行了 t.Parallel 后，也会设置 t.signal.
		// At this point, it is likely that FailNow was called on one of the
		// parent tests by one of the subtests. Continue aborting up the chain.
		runtime.Goexit()
	}
	return !t.failed
}


func tRunner(t *T, fn func(t *T)) {
	// When this goroutine is done, either because fn(t)
	// returned normally or because a test failure triggered
	// a call to runtime.Goexit, record the duration and send
	// a signal saying that the test is done.
	defer func() {
		defer func() {
			t.signal <- signal // 通知父测试，当前测试执行完毕
		}()

        // 如果有 parallel 的子测试，开始执行这些子测试并等待结束
		if len(t.sub) > 0 {
			// Run parallel subtests.
			// Decrease the running count for this test.
			t.context.release()
			close(t.barrier) // 通知 parallel 子测试执行
			// Wait for subtests to complete.
			for _, sub := range t.sub {
				<-sub.signal
			}
			t.duration += time.Since(cleanupStart)
			if !t.isParallel {
				// Reacquire the count for sequential tests. See comment in Run.
				t.context.waitParallel()
			}
		} else if t.isParallel {
			// Only release the count for this test if it was run as a parallel
			// test. See comment in Run method.
			t.context.release()
		}
		t.report() // Report after all subtests have finished.
		t.done = true // 测试以及子测试执行完毕 
	}()

	fn(t)

	t.mu.Lock()
	t.finished = true // fn 执行完毕
	t.mu.Unlock()
}

// 我们看看 t.Parallel() 的实现
// Parallel signals that this test is to be run in parallel with (and only with)
// other parallel tests. 
func (t *T) Parallel() {
	t.isParallel = true
	t.parent.sub = append(t.parent.sub, t) // 当前测试添加到父测试的 sub 列表中

	t.signal <- true   // 通知 Run() return
	<-t.parent.barrier // Wait for the parent test to complete.
	t.context.waitParallel()
}

// 我们看看 go test 中的 parallel 最大并行度的限制，是如何实现的。
// 这依赖于 t.context

type testContext struct {
	// Channel used to signal tests that are ready to be run in parallel.
	startParallel chan bool

	// running is the number of tests currently running in parallel.
	// This does not include tests that are waiting for subtests to complete.
	running int

	// numWaiting is the number tests waiting to be run in parallel.
	numWaiting int

	// maxParallel is a copy of the parallel flag.
	maxParallel int
}

// parallel 测试执行前，执行该函数
func (c *testContext) waitParallel() {
	c.mu.Lock()
	if c.running < c.maxParallel {
		c.running++
		c.mu.Unlock()
		return
	}
	c.numWaiting++
	c.mu.Unlock()
	<-c.startParallel // 当超过 maxParallel 的时候，从 startParallel 阻塞。
}

// parallel 测试执行完毕后，执行该函数
func (c *testContext) release() {
	c.mu.Lock()
	if c.numWaiting == 0 {
		c.running--
		c.mu.Unlock()
		return
	}
	c.numWaiting--
	c.mu.Unlock()
	c.startParallel <- true // Pick a waiting test to be run.
}

```

# testing.B

testing.B 是实现性能测试的核心数据结构。

# testing.M

go test 有两种方式来调度 test 的执行：
- 通过 testing.M

```go
func TestMain(m *testing.M) {
    println("TestMain setup.") // 执行一些初始化操作

    retCode := m.Run() // 执行测试，包括单元测试、性能测试和示例测试, 如果未执行该函数，则不会执行任何测试 ！！！

    println("TestMain tear-down.") // 执行一些收尾工作

    os.Exit(retCode)
}

```
- 自行调度

    这两种调度方式本质都是一样的。会给予当前包的所有测试构造一个父测试，然后执行该测试，参考 M.Run()
```go
func runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool) {
	ok = true
	for _, procs := range cpuList { // 由 test.cpu 指定
		runtime.GOMAXPROCS(procs)
		for i := uint(0); i < *count; i++ { // 由 test.count 指定
            // 每次测试前，创建一个 testContext
			ctx := newTestContext(*parallel, newMatcher(matchString, *match, "-test.run", *skip))
			ctx.deadline = deadline
            // 创建 root t 对象
			t := &T{
				common: common{
					signal:  make(chan bool, 1),
					barrier: make(chan bool),
					w:       os.Stdout,
				},
				context: ctx,
			}
            // 最关键的就是这一步。
            // func 就是抽象的父测试，该测试拉起所有的子测试，并等待所有子测试结束。
			tRunner(t, func(t *T) {
				for _, test := range tests {
					t.Run(test.Name, test.F)
				}
			})
			select {
			case <-t.signal: // 等待测试结束
			default:
				panic("internal error: tRunner exited without sending on t.signal")
			}
			ok = ok && !t.Failed()
			ran = ran || t.ran
		}
	}
	return ran, ok
}
```