package main

/*
1. reflect.MakeFunc 的工作原理

MakeFunc() 实现为：
func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {
	if typ.Kind() != Func {
		panic("reflect: call of MakeFunc with non-Func type")
	}

	t := typ.common()
	ftyp := (*funcType)(unsafe.Pointer(t))

	// code 是函数 makeFuncStub 的地址
	code := abi.FuncPCABI0(makeFuncStub)

	// makeFuncImpl contains a stack map for use by the runtime
	_, _, abi := funcLayout(ftyp, nil)

	// makeFuncImpl 是一个闭包对象
	impl := &makeFuncImpl{
		makeFuncCtxt: makeFuncCtxt{
			fn:      code,
			stack:   abi.stackPtrs,
			argLen:  abi.stackCallArgsSize,
			regPtrs: abi.inRegPtrs,
		},
		// MakeFunc 函数中的参数 typ 有什么用呢？以闭包的方式传递给函数 makeFuncStub
		ftyp: ftyp,
		fn:   fn,
	}

	// 本质上返回一个函数 Value，ptr 执行闭包对象 impl
	return Value{t, unsafe.Pointer(impl), flag(Func)}
}

所以 MakeFunc 本质上返回一个指向闭包对象 &makeFuncImpl 的函数变量， 而闭包对象对应的闭包函数是 makeFuncStub.
我们接着看看 makeFuncStub 的实现。

// makeFuncStub() 本质上是个汇编函数，底层调用了 callReflect 函数。
func makeFuncStub()

// callReflect 完成真正的函数调用
// ctxt is the "closure" generated by MakeFunc.
// frame is a pointer to the arguments to that closure on the stack.
// retValid points to a boolean which should be set when the results
// section of frame is set.

func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs) {
	ftyp := ctxt.ftyp
	f := ctxt.fn
	// 通过闭包对象中的 ftyp 才能知道函数入参是如何在寄存器和栈帧上分布的。
	_, _, abi := funcLayout(ftyp, nil)

	// 把函数的入参转化为 []Values， 从而调用 MakeFunc() 第二个参数指定的函数
	ptr := frame
	in := make([]Value, 0, int(ftyp.inCount))
	// 这里需要了解 ABI 的基本概念，本质上就是个约定，规定函数的入参和返回值在寄存器和栈帧上如何分布。 我们通过调用 funcLayout
	// 可以获取函数的 ABI 信息。 每一个变量对应若干 abiStep, 每一个 abiStep 描述将一个变量的哪一部分(offset + size) 应该复制到
	// 寄存器还是栈帧中(kind + 寄存器编号/stkOff)。

	for i, typ := range ftyp.in() {
		if typ.Size() == 0 {
			in = append(in, Zero(typ))
			continue
		}
		v := Value{typ, nil, flag(typ.Kind())}
		steps := abi.call.stepsForValue(i)
		// abiStepStack 表示变量在栈帧上分布
		if st := steps[0]; st.kind == abiStepStack {
			if ifaceIndir(typ) {
				// 如果 typ 类型是值类型，则通过 unsafe_New 分配 typ.size 大小的内存，然后将变量从栈帧复制到分配的内存中，然后
				// 让 value 的 ptr 指向这一块内存.
				v.ptr = unsafe_New(typ)
				if typ.size > 0 {
					typedmemmove(typ, v.ptr, add(ptr, st.stkOff, "typ.size > 0"))
				}
				v.flag |= flagIndir
			} else {
				// 如果 typ 是指针类型，则 直接让 value 的 ptr 等于栈帧中存储的指针。
				v.ptr = *(*unsafe.Pointer)(add(ptr, st.stkOff, "1-ptr"))
			}
		} else {
			if ifaceIndir(typ) {
				// 对于寄存器传入的参数，调用 unsafe_New 分配 typ.size 大小的内存，然后将变量从寄存器复制到分配的内存中。然后
				// 让 value 的 ptr 指向这一内存。
				v.flag |= flagIndir
				v.ptr = unsafe_New(typ)
				for _, st := range steps {
					switch st.kind {
					case abiStepIntReg:
						offset := add(v.ptr, st.offset, "precomputed value offset")
						intFromReg(regs, st.ireg, st.size, offset)
					case abiStepPointer:
						s := add(v.ptr, st.offset, "precomputed value offset")
						*((*unsafe.Pointer)(s)) = regs.Ptrs[st.ireg]
					case abiStepFloatReg:
						offset := add(v.ptr, st.offset, "precomputed value offset")
						floatFromReg(regs, st.freg, st.size, offset)
					case abiStepStack:
						panic("register-based return value has stack component")
					default:
						panic("unknown ABI part kind")
					}
				}
			} else {
				// Pointer-valued data gets put directly
				// into v.ptr.
				if steps[0].kind != abiStepPointer {
					print("kind=", steps[0].kind, ", type=", typ.String(), "\n")
					panic("mismatch between ABI description and types")
				}
				v.ptr = regs.Ptrs[steps[0].ireg]
			}
		}
		in = append(in, v)
	}

	// 调用底层的函数，即 MakeFunc() 第二个参数指定的函数 !!!
	out := f(in)
	numOut := ftyp.NumOut()
	// 判断函数的返回值数量是否跟 ftype 对应的函数的返回值数量一致。
	if len(out) != numOut {
		panic("reflect: wrong return count from function created by MakeFunc")
	}

	// 将返回值从 out([]Value) 拷贝到对应的栈帧或者寄存器中。
	if numOut > 0 {
		for i, typ := range ftyp.out() {
			v := out[i]
			if typ.size == 0 {
				continue
			}
		stepsLoop:
			for _, st := range abi.ret.stepsForValue(i) {
				switch st.kind {
				case abiStepStack:
					// 将值拷贝到栈帧中
					addr := add(ptr, st.stkOff, "precomputed stack arg offset")
					if v.flag&flagIndir != 0 {
						memmove(addr, v.ptr, st.size)
					} else {
						// This case must be a pointer type.
						*(*uintptr)(addr) = uintptr(v.ptr)
					}
					// There's only one step for a stack-allocated value.
					break stepsLoop
				case abiStepIntReg, abiStepPointer:
					// Copy values to "integer registers."
					// 将值拷贝到整型寄存器中。
					if v.flag&flagIndir != 0 {
						offset := add(v.ptr, st.offset, "precomputed value offset")
						intToReg(regs, st.ireg, st.size, offset)
					} else {
						// Only populate the Ints space on the return path.
						// This is safe because out is kept alive until the
						// end of this function, and the return path through
						// makeFuncStub has no preemption, so these pointers
						// are always visible to the GC.
						regs.Ints[st.ireg] = uintptr(v.ptr)
					}
				case abiStepFloatReg:
					// Copy values to "float registers."
					// 将值拷贝到浮点寄存器中
					if v.flag&flagIndir == 0 {
						panic("attempted to copy pointer to FP register")
					}
					offset := add(v.ptr, st.offset, "precomputed value offset")
					floatToReg(regs, st.freg, st.size, offset)
				default:
					panic("unknown ABI part kind")
				}
			}
		}
	}
}

从源码中可以看到，函数是 makeFuncStub 本质上就是根据函数的 ABI 将入参从栈帧或者寄存器上转化为 []Values， 然后调用 MakeFunc()
第二个参数指定的函数， 最后再次根据 ABI 信息， 将返回的 []Values 拷贝到函数的寄存器或者栈帧上，完成函数的调用。

2. reflect.MakeFunc 的使用场景
那么 MakeFunc 有什么用呢？一个典型的场景是可以实现动态函数。
TODO(wangguobin) 补充其他使用场景

3. value.Call()
value.Call() 函数实现为：
本质上就是根据 value 的 ABI 信息，现将参数从 in []Value 拷贝到栈帧和寄存器中，然后执行 v 对应的函数，然后将返回值从栈帧和寄存器中拷贝到
out []Value 中。
需要注意的是，将 in 拷贝到栈帧或者寄存器的的时候， 目前还没有 v 对应的函数的栈帧环境，因此是 通过一个中间栈帧和寄存器(动态分配)存放 in 对应
的数据，当真正要执行 v 对应的函数的时候，再将入参从中间栈帧和寄存器拷贝到 caller 的栈帧中，然后调用 v 对应的函数。 v 执行结束后，将返回值从
v 对应的栈帧拷贝到中间栈帧。最后再从中间栈帧拷贝到 out []Value 中。

func (v Value) call(op string, in []Value) []Value {
	// Get function pointer, type.
	t := (*funcType)(unsafe.Pointer(v.typ))
	var (
		fn       unsafe.Pointer
		rcvr     Value
		rcvrtype *rtype
	)
	if v.flag&flagMethod != 0 {
		rcvr = v
		rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)>>flagMethodShift)
	} else if v.flag&flagIndir != 0 {
		fn = *(*unsafe.Pointer)(v.ptr)
	} else {
		// fn 闭包对象指针
		fn = v.ptr
	}

	nin := len(in)
	if nin != t.NumIn() {
		panic("reflect.Value.Call: wrong argument count")
	}
	nout := t.NumOut()

	// Register argument space.
	var regArgs abi.RegArgs

	// Compute frame type.
	frametype, framePool, abi := funcLayout(t, rcvrtype)

	// Allocate a chunk of memory for frame if needed.
	var stackArgs unsafe.Pointer
	if frametype.size != 0 {
		if nout == 0 {
			stackArgs = framePool.Get().(unsafe.Pointer)
		} else {
			// 这里会分配一个中间栈帧，暂时存放 in 相关信息
			stackArgs = unsafe_New(frametype)
		}
	}
	frameSize := frametype.size

	// 根据 ABI 将 []Value 拷贝到中间栈帧，具体逻辑同 MakeFunc。
	for i, v := range in {
		v.mustBeExported()
		targ := t.In(i).(*rtype)
		// TODO(mknyszek): Figure out if it's possible to get some
		// scratch space for this assignment check. Previously, it
		// was possible to use space in the argument frame.
		v = v.assignTo("reflect.Value.Call", targ, nil)
	stepsLoop:
		for _, st := range abi.call.stepsForValue(i + inStart) {
			switch st.kind {
			case abiStepStack:
				// Copy values to the "stack."
				addr := add(stackArgs, st.stkOff, "precomputed stack arg offset")
				if v.flag&flagIndir != 0 {
					typedmemmove(targ, addr, v.ptr)
				} else {
					*(*unsafe.Pointer)(addr) = v.ptr
				}
				// There's only one step for a stack-allocated value.
				break stepsLoop
			case abiStepIntReg, abiStepPointer:
				// Copy values to "integer registers."
				if v.flag&flagIndir != 0 {
					offset := add(v.ptr, st.offset, "precomputed value offset")
					if st.kind == abiStepPointer {
						// Duplicate this pointer in the pointer area of the
						// register space. Otherwise, there's the potential for
						// this to be the last reference to v.ptr.
						regArgs.Ptrs[st.ireg] = *(*unsafe.Pointer)(offset)
					}
					intToReg(&regArgs, st.ireg, st.size, offset)
				} else {
					if st.kind == abiStepPointer {
						// See the comment in abiStepPointer case above.
						regArgs.Ptrs[st.ireg] = v.ptr
					}
					regArgs.Ints[st.ireg] = uintptr(v.ptr)
				}
			case abiStepFloatReg:
				// Copy values to "float registers."
				if v.flag&flagIndir == 0 {
					panic("attempted to copy pointer to FP register")
				}
				offset := add(v.ptr, st.offset, "precomputed value offset")
				floatToReg(&regArgs, st.freg, st.size, offset)
			default:
				panic("unknown ABI part kind")
			}
		}
	}
	// TODO(mknyszek): Remove this when we no longer have
	// caller reserved spill space.
	frameSize = align(frameSize, goarch.PtrSize)
	frameSize += abi.spill

	// 调用 call 完成函数调用，该函数 link 到 runtime.reflectcall， 后面分析 runtime.reflectcall 的实现。
	call(frametype, fn, stackArgs, uint32(frametype.size), uint32(abi.retOffset), uint32(frameSize), &regArgs)


	// 将返回值从中间栈帧拷贝到 ret []Value 中，最后返回 ret。
	var ret []Value
	if nout == 0 {
		if stackArgs != nil {
			typedmemclr(frametype, stackArgs)
			framePool.Put(stackArgs)
		}
	} else {
		// Wrap Values around return values in args.
		ret = make([]Value, nout)
		for i := 0; i < nout; i++ {
			tv := t.Out(i)
			if tv.Size() == 0 {
				// For zero-sized return value, args+off may point to the next object.
				// In this case, return the zero value instead.
				ret[i] = Zero(tv)
				continue
			}
			steps := abi.ret.stepsForValue(i)
			if st := steps[0]; st.kind == abiStepStack {
				// This value is on the stack. If part of a value is stack
				// allocated, the entire value is according to the ABI. So
				// just make an indirection into the allocated frame.
				fl := flagIndir | flag(tv.Kind())
				ret[i] = Value{tv.common(), add(stackArgs, st.stkOff, "tv.Size() != 0"), fl}
				// Note: this does introduce false sharing between results -
				// if any result is live, they are all live.
				// (And the space for the args is live as well, but as we've
				// cleared that space it isn't as big a deal.)
				continue
			}

			// Handle pointers passed in registers.
			if !ifaceIndir(tv.common()) {
				// Pointer-valued data gets put directly
				// into v.ptr.
				if steps[0].kind != abiStepPointer {
					print("kind=", steps[0].kind, ", type=", tv.String(), "\n")
					panic("mismatch between ABI description and types")
				}
				ret[i] = Value{tv.common(), regArgs.Ptrs[steps[0].ireg], flag(tv.Kind())}
				continue
			}
			s := unsafe_New(tv.common())
			for _, st := range steps {
				switch st.kind {
				case abiStepIntReg:
					offset := add(s, st.offset, "precomputed value offset")
					intFromReg(&regArgs, st.ireg, st.size, offset)
				case abiStepPointer:
					s := add(s, st.offset, "precomputed value offset")
					*((*unsafe.Pointer)(s)) = regArgs.Ptrs[st.ireg]
				case abiStepFloatReg:
					offset := add(s, st.offset, "precomputed value offset")
					floatFromReg(&regArgs, st.freg, st.size, offset)
				case abiStepStack:
					panic("register-based return value has stack component")
				default:
					panic("unknown ABI part kind")
				}
			}
			ret[i] = Value{tv.common(), s, flagIndir | flag(tv.Kind())}
		}
	}

	return ret
}

// 该函数完成 fn 的调用
// 在调用 fn 前，首先通过中间栈帧和寄存器来初始化 fn 的调用环境，然后调用 fn， 最后将 fn 的返回值拷贝到中间栈帧(stackArgs)和寄存器(regArgs)中。
// TODO(wangguobin) 可以通过 objdump 来查看此函数的实现。
func reflectcall(stackArgsType *_type, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)

*/