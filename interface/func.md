# reflect.MakeFunc

## 使用

```go
func add(inputs []reflect.Value) []reflect.Value {
	var ret int64
	for _, input := range inputs {
		ret += input.Int()
	}

	return []reflect.Value{reflect.ValueOf(ret)}
}

func main() {

	fn := reflect.MakeFunc(reflect.TypeOf((func(i, j int) int64)(nil)), add)

	// 两种调用方式均可。
	ret := fn.Interface().(func(int, int) int64)(1, 2)
	fmt.Printf("%d\n", ret) // Output: 3

	// rets := fn.Call([]reflect.Value{reflect.ValueOf(1), reflect.ValueOf(2)})
	// fmt.Printf("%d\n", rets[0].Int()) // Output: 3
}

```

## 原理

MakeFunc() 实现为：
```go
func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {
	if typ.Kind() != Func {
		panic("reflect: call of MakeFunc with non-Func type")
	}

	t := typ.common()
	ftyp := (*funcType)(unsafe.Pointer(t))

	// code 是函数 makeFuncStub 的地址
	code := abi.FuncPCABI0(makeFuncStub)

	// makeFuncImpl contains a stack map for use by the runtime
	_, _, abi := funcLayout(ftyp, nil)

	// makeFuncImpl 是一个闭包对象
	impl := &makeFuncImpl{
		makeFuncCtxt: makeFuncCtxt{
			fn:      code,
			stack:   abi.stackPtrs,
			argLen:  abi.stackCallArgsSize,
			regPtrs: abi.inRegPtrs,
		},
		// MakeFunc 函数中的参数 typ 有什么用呢？以闭包的方式传递给函数 makeFuncStub
		ftyp: ftyp,
		fn:   fn,
	}

	// 本质上返回一个函数 Value，ptr 执行闭包对象 impl
	return Value{t, unsafe.Pointer(impl), flag(Func)}
}
```

所以 MakeFunc 本质上返回一个指向闭包对象 &makeFuncImpl 的函数变量， 而闭包对象对应的闭包函数是 makeFuncStub.
我们接着看看 makeFuncStub 的实现。

// makeFuncStub() 本质上是个汇编函数，底层调用了 callReflect 函数。
func makeFuncStub()

```go
// callReflect 完成真正的函数调用
// ctxt is the "closure" generated by MakeFunc.
// frame is a pointer to the arguments to that closure on the stack.
// retValid points to a boolean which should be set when the results
// section of frame is set.

func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs) {
	ftyp := ctxt.ftyp
	f := ctxt.fn
	// 通过闭包对象中的 ftyp 才能知道函数入参是如何在寄存器和栈帧上分布的。
	_, _, abi := funcLayout(ftyp, nil)

	// 把函数的入参转化为 []Values， 从而调用 MakeFunc() 第二个参数指定的函数
	ptr := frame
	in := make([]Value, 0, int(ftyp.inCount))
	// 这里需要了解 ABI 的基本概念，本质上就是个约定，规定函数的入参和返回值在寄存器和栈帧上如何分布。 我们通过调用 funcLayout
	// 可以获取函数的 ABI 信息。 每一个变量对应若干 abiStep, 每一个 abiStep 描述将一个变量的哪一部分(offset + size) 应该复制到
	// 寄存器还是栈帧中(kind + 寄存器编号/stkOff)。

	for i, typ := range ftyp.in() {
		if typ.Size() == 0 {
			in = append(in, Zero(typ))
			continue
		}
		v := Value{typ, nil, flag(typ.Kind())}
		steps := abi.call.stepsForValue(i)
		// abiStepStack 表示变量在栈帧上分布
		if st := steps[0]; st.kind == abiStepStack {
			if ifaceIndir(typ) {
				// 如果 typ 类型是值类型，则通过 unsafe_New 分配 typ.size 大小的内存，然后将变量从栈帧复制到分配的内存中，然后
				// 让 value 的 ptr 指向这一块内存.
				v.ptr = unsafe_New(typ)
				if typ.size > 0 {
					typedmemmove(typ, v.ptr, add(ptr, st.stkOff, "typ.size > 0"))
				}
				v.flag |= flagIndir
			} else {
				// 如果 typ 是指针类型，则 直接让 value 的 ptr 等于栈帧中存储的指针。
				v.ptr = *(*unsafe.Pointer)(add(ptr, st.stkOff, "1-ptr"))
			}
		} else {
			if ifaceIndir(typ) {
				// 对于寄存器传入的参数，调用 unsafe_New 分配 typ.size 大小的内存，然后将变量从寄存器复制到分配的内存中。然后
				// 让 value 的 ptr 指向这一内存。
				v.flag |= flagIndir
				v.ptr = unsafe_New(typ)
				for _, st := range steps {
					switch st.kind {
					case abiStepIntReg:
						offset := add(v.ptr, st.offset, "precomputed value offset")
						intFromReg(regs, st.ireg, st.size, offset)
					case abiStepPointer:
						s := add(v.ptr, st.offset, "precomputed value offset")
						*((*unsafe.Pointer)(s)) = regs.Ptrs[st.ireg]
					case abiStepFloatReg:
						offset := add(v.ptr, st.offset, "precomputed value offset")
						floatFromReg(regs, st.freg, st.size, offset)
					case abiStepStack:
						panic("register-based return value has stack component")
					default:
						panic("unknown ABI part kind")
					}
				}
			} else {
				// Pointer-valued data gets put directly
				// into v.ptr.
				if steps[0].kind != abiStepPointer {
					print("kind=", steps[0].kind, ", type=", typ.String(), "\n")
					panic("mismatch between ABI description and types")
				}
				v.ptr = regs.Ptrs[steps[0].ireg]
			}
		}
		in = append(in, v)
	}

	// 调用底层的函数，即 MakeFunc() 第二个参数指定的函数 !!!
	out := f(in)
	numOut := ftyp.NumOut()
	// 判断函数的返回值数量是否跟 ftype 对应的函数的返回值数量一致。
	if len(out) != numOut {
		panic("reflect: wrong return count from function created by MakeFunc")
	}

	// 将返回值从 out([]Value) 拷贝到对应的栈帧或者寄存器中。
	if numOut > 0 {
		for i, typ := range ftyp.out() {
			v := out[i]
			if typ.size == 0 {
				continue
			}
		stepsLoop:
			for _, st := range abi.ret.stepsForValue(i) {
				switch st.kind {
				case abiStepStack:
					// 将值拷贝到栈帧中
					addr := add(ptr, st.stkOff, "precomputed stack arg offset")
					if v.flag&flagIndir != 0 {
						memmove(addr, v.ptr, st.size)
					} else {
						// This case must be a pointer type.
						*(*uintptr)(addr) = uintptr(v.ptr)
					}
					// There's only one step for a stack-allocated value.
					break stepsLoop
				case abiStepIntReg, abiStepPointer:
					// Copy values to "integer registers."
					// 将值拷贝到整型寄存器中。
					if v.flag&flagIndir != 0 {
						offset := add(v.ptr, st.offset, "precomputed value offset")
						intToReg(regs, st.ireg, st.size, offset)
					} else {
						// Only populate the Ints space on the return path.
						// This is safe because out is kept alive until the
						// end of this function, and the return path through
						// makeFuncStub has no preemption, so these pointers
						// are always visible to the GC.
						regs.Ints[st.ireg] = uintptr(v.ptr)
					}
				case abiStepFloatReg:
					// Copy values to "float registers."
					// 将值拷贝到浮点寄存器中
					if v.flag&flagIndir == 0 {
						panic("attempted to copy pointer to FP register")
					}
					offset := add(v.ptr, st.offset, "precomputed value offset")
					floatToReg(regs, st.freg, st.size, offset)
				default:
					panic("unknown ABI part kind")
				}
			}
		}
	}
}
```

从源码中可以看到，函数是 makeFuncStub 本质上就是根据函数的 ABI 将入参从栈帧或者寄存器上转化为 []Values， 然后调用 MakeFunc()
第二个参数指定的函数， 最后再次根据 ABI 信息， 将返回的 []Values 拷贝到函数的寄存器或者栈帧上，完成函数的调用。

所以，MakeFunc 到底干了什么呢？ 实际上并没有生成新的函数，函数本来就只在编译期生成。MakeFunc 返回的函数对象对应的函数是 makeFuncStub.
makeFuncStub 怎么可以适用于任何函数呢？

首先，通过 ABI 来获取目标函数类型入参和返回值的栈帧及寄存器布局， 从而可以获取任意函数类型的入参。

其次，就是 MakeFunc() 的第二个参数。 我们可以看到它的原型为 func(args []Values) []Values. 正是入参和返回值的列表化处理，使得只需要定义
一个 func(args []Values) []Values 便可通过 MakeFunc() 生成多种类型的函数对象(前提是这些函数对象的逻辑可以统一起来)。

# reflect.MakeFunc 的使用场景
那么 MakeFunc 有什么用呢?

- Mock

Mock 函数的时候，我们根据函数的类型以及函数 Mock 的返回值，来生成一个函数。然后通过将待 Mock 的目标函数的头部指令转化为
"mov $to, %rdx(设置闭包对象地址到 rdx 中);
jmp *%rds (跳转到 MakeFunc 生成的函数)"，
即可实现函数的 Mock

TODO(wangguobin): 补充其他使用场景

# value.Call()
value.Call() 函数实现为：
本质上就是根据 value 的 ABI 信息，先将参数从 in []Value 拷贝到栈帧和寄存器中，然后执行 v 对应的函数，然后将返回值从栈帧和寄存器中拷贝到
out []Value 中。

需要注意的是，将 in 拷贝到栈帧或者寄存器的的时候， 目前还没有 v 对应的函数的栈帧环境，因此是 通过一个中间栈帧和寄存器(动态分配)存放 in 对应
的数据，当真正要执行 v 对应的函数的时候，再将入参从中间栈帧和寄存器拷贝到 caller 的栈帧中，然后调用 v 对应的函数。 v 执行结束后，将返回值从
v 对应的栈帧拷贝到中间栈帧。最后再从中间栈帧拷贝到 out []Value 中。

```go
func (v Value) call(op string, in []Value) []Value {
	// Get function pointer, type.
	t := (*funcType)(unsafe.Pointer(v.typ))
	var (
		fn       unsafe.Pointer
		rcvr     Value
		rcvrtype *rtype
	)
	if v.flag&flagMethod != 0 {
		rcvr = v
		rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)>>flagMethodShift)
	} else if v.flag&flagIndir != 0 {
		fn = *(*unsafe.Pointer)(v.ptr)
	} else {
		// fn 闭包对象指针
		fn = v.ptr
	}

	nin := len(in)
	if nin != t.NumIn() {
		panic("reflect.Value.Call: wrong argument count")
	}
	nout := t.NumOut()

	// Register argument space.
	var regArgs abi.RegArgs

	// Compute frame type.
	frametype, framePool, abi := funcLayout(t, rcvrtype)

	// Allocate a chunk of memory for frame if needed.
	var stackArgs unsafe.Pointer
	if frametype.size != 0 {
		if nout == 0 {
			stackArgs = framePool.Get().(unsafe.Pointer)
		} else {
			// 这里会分配一个中间栈帧，暂时存放 in 相关信息
			stackArgs = unsafe_New(frametype)
		}
	}
	frameSize := frametype.size

	// 根据 ABI 将 []Value 拷贝到中间栈帧，具体逻辑同 MakeFunc。
	for i, v := range in {
	stepsLoop:
		for _, st := range abi.call.stepsForValue(i + inStart) {
			switch st.kind {
			case abiStepStack:
				// Copy values to the "stack."
				addr := add(stackArgs, st.stkOff, "precomputed stack arg offset")
				if v.flag&flagIndir != 0 {
					typedmemmove(targ, addr, v.ptr)
				} else {
					*(*unsafe.Pointer)(addr) = v.ptr
				}
				// There's only one step for a stack-allocated value.
				break stepsLoop
			case abiStepIntReg, abiStepPointer:
				// Copy values to "integer registers."
				if v.flag&flagIndir != 0 {
					offset := add(v.ptr, st.offset, "precomputed value offset")
					if st.kind == abiStepPointer {
						// Duplicate this pointer in the pointer area of the
						// register space. Otherwise, there's the potential for
						// this to be the last reference to v.ptr.
						regArgs.Ptrs[st.ireg] = *(*unsafe.Pointer)(offset)
					}
					intToReg(&regArgs, st.ireg, st.size, offset)
				} else {
					if st.kind == abiStepPointer {
						// See the comment in abiStepPointer case above.
						regArgs.Ptrs[st.ireg] = v.ptr
					}
					regArgs.Ints[st.ireg] = uintptr(v.ptr)
				}
			case abiStepFloatReg:
				// Copy values to "float registers."
				if v.flag&flagIndir == 0 {
					panic("attempted to copy pointer to FP register")
				}
				offset := add(v.ptr, st.offset, "precomputed value offset")
				floatToReg(&regArgs, st.freg, st.size, offset)
			default:
				panic("unknown ABI part kind")
			}
		}
	}

	// 调用 call 完成函数调用，该函数 link 到 runtime.reflectcall， 后面分析 runtime.reflectcall 的实现。
	call(frametype, fn, stackArgs, uint32(frametype.size), uint32(abi.retOffset), uint32(frameSize), &regArgs)


	// 将返回值从中间栈帧拷贝到 ret []Value 中，最后返回 ret。
	var ret []Value
	if nout == 0 {
		if stackArgs != nil {
			typedmemclr(frametype, stackArgs)
			framePool.Put(stackArgs)
		}
	} else {
		// Wrap Values around return values in args.
		ret = make([]Value, nout)
		for i := 0; i < nout; i++ {
			tv := t.Out(i)
			if tv.Size() == 0 {
				// For zero-sized return value, args+off may point to the next object.
				// In this case, return the zero value instead.
				ret[i] = Zero(tv)
				continue
			}
			steps := abi.ret.stepsForValue(i)
			if st := steps[0]; st.kind == abiStepStack {
				// This value is on the stack. If part of a value is stack
				// allocated, the entire value is according to the ABI. So
				// just make an indirection into the allocated frame.
				fl := flagIndir | flag(tv.Kind())
				ret[i] = Value{tv.common(), add(stackArgs, st.stkOff, "tv.Size() != 0"), fl}
				// Note: this does introduce false sharing between results -
				// if any result is live, they are all live.
				// (And the space for the args is live as well, but as we've
				// cleared that space it isn't as big a deal.)
				continue
			}

			// Handle pointers passed in registers.
			if !ifaceIndir(tv.common()) {
				// Pointer-valued data gets put directly
				// into v.ptr.
				if steps[0].kind != abiStepPointer {
					print("kind=", steps[0].kind, ", type=", tv.String(), "\n")
					panic("mismatch between ABI description and types")
				}
				ret[i] = Value{tv.common(), regArgs.Ptrs[steps[0].ireg], flag(tv.Kind())}
				continue
			}
			s := unsafe_New(tv.common())
			for _, st := range steps {
				switch st.kind {
				case abiStepIntReg:
					offset := add(s, st.offset, "precomputed value offset")
					intFromReg(&regArgs, st.ireg, st.size, offset)
				case abiStepPointer:
					s := add(s, st.offset, "precomputed value offset")
					*((*unsafe.Pointer)(s)) = regArgs.Ptrs[st.ireg]
				case abiStepFloatReg:
					offset := add(s, st.offset, "precomputed value offset")
					floatFromReg(&regArgs, st.freg, st.size, offset)
				case abiStepStack:
					panic("register-based return value has stack component")
				default:
					panic("unknown ABI part kind")
				}
			}
			ret[i] = Value{tv.common(), s, flagIndir | flag(tv.Kind())}
		}
	}

	return ret
}
```

该函数完成 fn 的调用, 在调用 fn 前，首先通过中间栈帧和寄存器来初始化 fn 的调用环境，然后调用 fn， 最后将 fn 的返回值拷贝到中间栈帧(stackArgs)和寄存器(regArgs)中。
func reflectcall(stackArgsType *_type, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)

`reflectcall` 对应的 runtime 函数定义在 `runtime/asm_amd64.s` 中，该汇编函数会根据 stackArgsSize 决定调用什么样的函数：
```go
#define DISPATCH(NAME,MAXSIZE)		\
	CMPQ	CX, $MAXSIZE;		\
	JA	3(PC);			\
	MOVQ	$NAME(SB), AX;		\
	JMP	AX
// Note: can't just "JMP NAME(SB)" - bad inlining results.

TEXT ·reflectcall<ABIInternal>(SB), NOSPLIT, $0-32
	MOVLQZX argsize+24(FP), CX
	DISPATCH(runtime·call16, 16)
	DISPATCH(runtime·call32, 32)
	DISPATCH(runtime·call64, 64)
	DISPATCH(runtime·call128, 128)
	...
```

我们这里以 `runtime.call16` 举例，看看其汇编实现：
```go
000000000045b060 <runtime.call16>:
45b060:	65 48 8b 0c 25 28 00 	mov    %gs:0x28,%rcx
45b067:	00 00 
45b069:	48 8b 89 00 00 00 00 	mov    0x0(%rcx),%rcx
45b070:	48 3b 61 10          	cmp    0x10(%rcx),%rsp
45b074:	76 5c                	jbe    45b0d2 <runtime.call16+0x72>
45b076:	48 83 ec 18          	sub    $0x18,%rsp
45b07a:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
45b07f:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
45b084:	48 8b 59 20          	mov    0x20(%rcx),%rbx
45b088:	48 85 db             	test   %rbx,%rbx
45b08b:	75 4c                	jne    45b0d9 <runtime.call16+0x79>
45b08d:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
45b092:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
45b096:	48 89 e7             	mov    %rsp,%rdi
45b099:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi) // rep movsb 从 %rsi 每次拷贝一字节到 %rid，直到 %ecx 为 0
45b09b:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
45b0a0:	48 8b 02             	mov    (%rdx),%rax
45b0a3:	ff d0                	callq  *%rax
45b0a5:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
45b0aa:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi	// 分配栈帧起始地址
45b0af:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
45b0b3:	8b 5c 24 3c          	mov    0x3c(%rsp),%ebx // 返回值偏移量
45b0b7:	48 89 e6             	mov    %rsp,%rsi
45b0ba:	48 01 df             	add    %rbx,%rdi // 返回值起始地址
45b0bd:	48 01 de             	add    %rbx,%rsi // 调用 *%rax，返回值起始地址
45b0c0:	48 29 d9             	sub    %rbx,%rcx
45b0c3:	e8 f8 ec ff ff       	callq  459dc0 <callRet> // 调用 callRet 拷贝
45b0c8:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
45b0cd:	48 83 c4 18          	add    $0x18,%rsp
45b0d1:	c3                   	retq
```

# Method

## 如果通过反射的方式来调用 Method 呢？

```go

type myInt int

func (m *myInt) Set(p int) {
	*m = myInt(p)
}

func main() {

	var i myInt

	rv := reflect.ValueOf(&i)

	mv := rv.MethodByName("Set")

	mv.Interface().(func(int))(1)

	fmt.Printf("%d\n", int(i)) // Output: 1
}

```

## 工作原理

```go
// MethodByName 并不会返回真正的 methodValue，只有调用 Interface() 的时候，才会转化为
// 真正的 methodValue。
func (v Value) Method(i int) Value {
	fl := v.flag.ro() | (v.flag & flagIndir)
	fl |= flag(Func)
	fl |= flag(i)<<flagMethodShift | flagMethod
	// 仅仅是修改了下 flag
	return Value{v.typ(), v.ptr, fl}
}

func (v Value) Interface() (i any) {
	return valueInterface(v, true)
}

func valueInterface(v Value, safe bool) any {
	// Method()返回的Value 中的 flagMethod 设置为 true
	if v.flag&flagMethod != 0 {
		v = makeMethodValue("Interface", v)
	}

	// TODO: pass safe to packEface so we don't need to copy if safe==true?
	return packEface(v)
}

// makeMethodValue 本质就是创建个 methodValue 
func makeMethodValue(op string, v Value) Value {
	// Ignoring the flagMethod bit, v describes the receiver, not the method type.
	fl := v.flag & (flagRO | flagAddr | flagIndir)
	fl |= flag(v.typ().Kind())
	rcvr := Value{v.typ(), v.ptr, fl}

	// v.Type returns the actual type of the method value.
	ftyp := (*funcType)(unsafe.Pointer(v.Type().(*rtype)))

	// code 为真正要执行的函数的入口地址
	code := methodValueCallCodePtr()

	// methodValue contains a stack map for use by the runtime
	_, _, abid := funcLayout(ftyp, nil)
	// fv 是个闭包对象
	fv := &methodValue{
		makeFuncCtxt: makeFuncCtxt{
			fn:      code,
			stack:   abid.stackPtrs,
			argLen:  abid.stackCallArgsSize,
			regPtrs: abid.inRegPtrs,
		},
		method: int(v.flag) >> flagMethodShift,
		rcvr:   rcvr,
	}

	// 返回 methodValue， ptr 指向 fv
	return Value{ftyp.Common(), unsafe.Pointer(fv), v.flag&flagRO | flag(Func)}
}

// 关键问题：不同的 method 的入参是不同的，如何在一个函数中完成这些不同的入参的处理？

// 上个函数中的 code 即为该函数的入口地址
TEXT ·methodValueCall(SB),(NOSPLIT|WRAPPER),$312
	NO_LOCAL_POINTERS
	// NO_LOCAL_POINTERS is a lie. The stack map for the two locals in this
	// frame is specially handled in the runtime. See the comment above LOCAL_RETVALID.
	LEAQ	LOCAL_REGARGS(SP), R12
	CALL	runtime·spillArgs(SB)
	MOVQ	DX, 24(SP) // outside of moveMakeFuncArgPtrs's arg area
	MOVQ	DX, 0(SP)
	MOVQ	R12, 8(SP)
	CALL	·moveMakeFuncArgPtrs(SB)
	MOVQ	24(SP), DX
	MOVQ	DX, 0(SP) // 闭包对象
	LEAQ	argframe+0(FP), CX
	MOVQ	CX, 8(SP) // 入参起始地址
	MOVB	$0, LOCAL_RETVALID(SP)
	LEAQ	LOCAL_RETVALID(SP), AX
	MOVQ	AX, 16(SP)
	LEAQ	LOCAL_REGARGS(SP), AX
	MOVQ	AX, 24(SP) // 寄存器
	CALL	·callMethod(SB)
	LEAQ	LOCAL_REGARGS(SP), R12
	CALL	runtime·unspillArgs(SB)
	RET

// ctxt is the "closure" generated by makeVethodValue.
// frame is a pointer to the arguments to that closure on the stack.
// retValid points to a boolean which should be set when the results
// section of frame is set.
//
// regs contains the argument values passed in registers and will contain
// the values returned from ctxt.fn in registers.
//
// 核心工作原理为：将 receiver 和 入参从 frame 和 regs 拷贝到一段内存中(methodFrame)，
// 然后调用 call()，call() 中将入参从 methodFrame 拷贝到 stack 和 regs 并完成真正函数的调用
// 并将 result 拷贝到 methodFrame.
// 最后 callMethod() 将 result 从 methodFrame 拷贝到 frame 和 regs 中
func callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs) {
	rcvr := ctxt.rcvr
	// methodFn 真正要执行的函数
	rcvrType, valueFuncType, methodFn := methodReceiver("call", rcvr, ctxt.method)

	// There are two ABIs at play here.
	//
	// methodValueCall was invoked with the ABI assuming there was no
	// receiver ("value ABI") and that's what frame and regs are holding.
	//
	// Meanwhile, we need to actually call the method with a receiver, which
	// has its own ABI ("method ABI"). Everything that follows is a translation
	// between the two.
	_, _, valueABI := funcLayout(valueFuncType, nil)
	valueFrame, valueRegs := frame, regs
	methodFrameType, methodFramePool, methodABI := funcLayout(valueFuncType, rcvrType)

	// 分配 methodFrame
	// Make a new frame that is one word bigger so we can store the receiver.
	// This space is used for both arguments and return values.
	methodFrame := methodFramePool.Get().(unsafe.Pointer)
	var methodRegs abi.RegArgs

	// Deal with the receiver. It's guaranteed to only be one word in size.
	// 首先将 receiver 拷贝到 methodFrame 或者 methodRegs
	switch st := methodABI.call.steps[0]; st.kind {
	case abiStepStack:
		// Only copy the receiver to the stack if the ABI says so.
		// Otherwise, it'll be in a register already.
		storeRcvr(rcvr, methodFrame)
	case abiStepPointer:
		// Put the receiver in a register.
		storeRcvr(rcvr, unsafe.Pointer(&methodRegs.Ptrs[st.ireg]))
		fallthrough
	case abiStepIntReg:
		storeRcvr(rcvr, unsafe.Pointer(&methodRegs.Ints[st.ireg]))
	case abiStepFloatReg:
		storeRcvr(rcvr, unsafe.Pointer(&methodRegs.Floats[st.freg]))
	default:
		panic("unknown ABI parameter kind")
	}

	// Translate the rest of the arguments.
	// 将入参拷贝到 methodFrame 或者 methodRegs
	for i, t := range valueFuncType.InSlice() {...}


	// Call.
	// Call copies the arguments from scratch to the stack, calls fn,
	// and then copies the results back into scratch.
	call(methodFrameType, methodFn, methodFrame, uint32(methodFrameType.Size()), uint32(methodABI.retOffset), uint32(methodFrameSize), &methodRegs)

	// Copy return values.
	//
	if retSize := methodFrameType.Size() - methodABI.retOffset; retSize > 0 {
		valueRet := add(valueFrame, valueABI.retOffset, "valueFrame's size > retOffset")
		methodRet := add(methodFrame, methodABI.retOffset, "methodFrame's size > retOffset")
		// This copies to the stack. Write barriers are not needed.
		// 将 result 拷贝到 frame
		memmove(valueRet, methodRet, retSize)
	}
	
	// ...
}
```