问题：
1、协程是如何从栈上找出引用堆变量的变量的？
猜测：函数运行，如果某个局部变量引用了堆变量，会将此记录到协程相应的数据结构中。 gc 携程只需要扫描工作协程的该变量即可。
如此实现原因：类似 epoll 将 gc 协程扫描工作分摊到各个工作协程。效率较高。其次，如果 gc 协程直接从工作协程栈上找引用堆变量的局部变量，我想不到很好的方法。gc 协程能看到的也就是工作协程的栈顶、栈基这些基本信息。

2、mark-sweep 标记-清扫 算法
什么时候算标记完成呢？
清扫阶段，如果工作协程修改了引用关系，需要重新标记吗？

3、既然是三色标记，为什么 go 内部中使用 bit 位来标记？ 这不是只能标记两种状态吗？
0 为白色，未标记
1 且对象入队 为灰色
1 且对象出队，表示对象引用所有对象均标记，为黑色
